<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>RNeXML: The next-generation phylogenetics format comes to R</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{An Introduction to the RNeXML package}
-->

<p><a href="https://travis-ci.org/ropensci/RNeXML"><img src="https://api.travis-ci.org/ropensci/RNeXML.png" alt="Build Status"/></a></p>

<h1>RNeXML: The next-generation phylogenetics format comes to R</h1>

<p>An R package for reading, writing, integrating and publishing data using the Ecological Metadata Language (EML) format.   </p>

<ul>
<li><strong>Note:</strong> This package is still in active development and not yet submitted to CRAN.  Functions and documentation may be incomplete and subject to change.<br/></li>
<li>Maintainer: Carl Boettiger</li>
<li>Authors: Carl Boettiger, Scott Chamberlain, Hilmar Lapp, Kseniia Shumelchyk, Rutger Vos</li>
<li>License: BSD-3 </li>
<li><a href="https://github.com/ropensci/RNeXML/issues">Issues</a>: Bug reports, feature requests, and development discussion.</li>
</ul>

<p>An extensive and rapidly growing collection of richly annotated phylogenetics data is now available in the NeXML format. NeXML relies on state-of-the-art data exchange technology to provide a format that can be both validated and extended, providing a data quality assurance and and adaptability to the future that is lacking in other formats <a href="http://doi.org/10.1093/sysbio/sys025" title="NeXML: Rich, Extensible, and Verifiable Representation of Comparative Data and Metadata.">Vos et al 2012</a>. </p>

<h2>Getting Started</h2>

<p>The development version of RNeXML is <a href="https://github.com/ropensci/RNeXML">available on Github</a>.  With the <code>devtools</code> package installed on your system, RNeXML can be installed using:</p>

<pre><code class="r">library(devtools)
install_github(&quot;RNeXML&quot;, &quot;ropensci&quot;)
library(RNeXML)
</code></pre>

<p>Read in a <code>nexml</code> file into the <code>ape::phylo</code> format:</p>

<pre><code class="r">f &lt;- system.file(&quot;examples&quot;, &quot;comp_analysis.xml&quot;, package=&quot;RNeXML&quot;)
nexml &lt;- nexml_read(f)
tr &lt;- get_trees(nexml) # or: as(nexml, &quot;phylo&quot;)
plot(tr)
</code></pre>

<p><img src="http://i.imgur.com/Jsd1i5Y.png" alt="plot of chunk unnamed-chunk-4"/> </p>

<p>Write an <code>ape::phylo</code> tree into the <code>nexml</code> format:</p>

<pre><code class="r">data(bird.orders)
nexml_write(bird.orders, &quot;test.xml&quot;)
</code></pre>

<pre><code>[1] &quot;test.xml&quot;
</code></pre>

<p>A key feature of NeXML is the ability to formally validate the construction of the data file against the standard (the lack of such a feature in nexus files had lead to inconsistencies across different software platforms, and some files that cannot be read at all).  While it is difficult to make an invalid NeXML file from <code>RNeXML</code>, it never hurts to validate just to be sure:</p>

<pre><code class="r">nexml_validate(&quot;test.xml&quot;)
</code></pre>

<pre><code>[1] TRUE
</code></pre>

<p>Extract metadata from the NeXML file: </p>

<pre><code class="r">birds &lt;- nexml_read(&quot;test.xml&quot;)
get_taxa(birds)
</code></pre>

<pre><code> [1] &quot;Struthioniformes&quot; &quot;Tinamiformes&quot;     &quot;Craciformes&quot;     
 [4] &quot;Galliformes&quot;      &quot;Anseriformes&quot;     &quot;Turniciformes&quot;   
 [7] &quot;Piciformes&quot;       &quot;Galbuliformes&quot;    &quot;Bucerotiformes&quot;  
[10] &quot;Upupiformes&quot;      &quot;Trogoniformes&quot;    &quot;Coraciiformes&quot;   
[13] &quot;Coliiformes&quot;      &quot;Cuculiformes&quot;     &quot;Psittaciformes&quot;  
[16] &quot;Apodiformes&quot;      &quot;Trochiliformes&quot;   &quot;Musophagiformes&quot; 
[19] &quot;Strigiformes&quot;     &quot;Columbiformes&quot;    &quot;Gruiformes&quot;      
[22] &quot;Ciconiiformes&quot;    &quot;Passeriformes&quot;   
</code></pre>

<pre><code class="r">get_metadata(birds) 
</code></pre>

<pre><code>                      dcterms:bibliographicCitation 
                                                 NA 
                                         cc:license 
&quot;http://creativecommons.org/publicdomain/zero/1.0/&quot; 
</code></pre>

<hr/>

<p>Add basic additional metadata:  </p>

<pre><code class="r">  nexml_write(bird.orders, file=&quot;meta_example.xml&quot;,
              title = &quot;My test title&quot;,
              description = &quot;A description of my test&quot;,
              creator = &quot;Carl Boettiger &lt;cboettig@gmail.com&gt;&quot;,
              publisher = &quot;unpublished data&quot;,
              pubdate = &quot;2012-04-01&quot;)
</code></pre>

<pre><code>[1] &quot;meta_example.xml&quot;
</code></pre>

<p>By default, <code>RNeXML</code> adds certain metadata, including the NCBI taxon id numbers for all named taxa.  This acts a check on the spelling and definitions of the taxa as well as providing a link to additional metadata about each taxonomic unit described in the dataset.  </p>

<h3>Advanced annotation</h3>

<p>We can also add arbitrary metadata to a NeXML tree by define <code>meta</code> objects:</p>

<pre><code class="r">modified &lt;- meta(property = &quot;prism:modificationDate&quot;,
                 content = &quot;2013-10-04&quot;)
</code></pre>

<p>Advanced use requires specifying the namespace used.  Metadata follows the RDFa conventions.  Here we indicate the modification date using the prism vocabulary. This namespace is included by default, as it is used for some of the basic metadata shown in the previous example.  We can see from this list:</p>

<pre><code class="r">RNeXML:::nexml_namespaces
</code></pre>

<pre><code>                                             nex 
                     &quot;http://www.nexml.org/2009&quot; 
                                             xsi 
     &quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
                                             xml 
          &quot;http://www.w3.org/XML/1998/namespace&quot; 
                                            cdao 
       &quot;http://purl.obolibrary.org/obo/cdao.owl&quot; 
                                             xsd 
             &quot;http://www.w3.org/2001/XMLSchema#&quot; 
                                              dc 
              &quot;http://purl.org/dc/elements/1.1/&quot; 
                                         dcterms 
                     &quot;http://purl.org/dc/terms/&quot; 
                                           prism 
&quot;http://prismstandard.org/namespaces/1.2/basic/&quot; 
                                              cc 
                &quot;http://creativecommons.org/ns#&quot; 
                                            ncbi 
         &quot;http://www.ncbi.nlm.nih.gov/taxonomy#&quot; 
                                              tc 
 &quot;http://rs.tdwg.org/ontology/voc/TaxonConcept#&quot; 
</code></pre>

<p>This next block defines a resource (link), described by the <code>rel</code> attribute as a homepage, a term in the <code>foaf</code> vocabulalry.  Becuase <code>foaf</code> is not a default namespace, we will have to provide its URL in the full definition below. </p>

<pre><code class="r">website &lt;- meta(href = &quot;http://carlboettiger.info&quot;, 
                rel = &quot;foaf:homepage&quot;)
</code></pre>

<p>Here we create a history node using the <code>skos</code> namespace.  We can also add id values to any metadata element to make the element easier to reference externally: </p>

<pre><code class="r">  history &lt;- meta(property = &quot;skos:historyNote&quot;, 
                  content = &quot;Mapped from the bird.orders data in the ape package using RNeXML&quot;,
                  id = &quot;meta123&quot;)
</code></pre>

<p>For this kind of richer annotation, it is best to build up our NeXML object sequentially. Frist
we will add <code>bird.orders</code> phylogeny to a new phylogenetic object, and then we will add the metadata
elements created above to this object. Finally, we will write the object out as an XML file:</p>

<pre><code class="r">  birds &lt;- add_trees(bird.orders)
  birds &lt;- add_meta(meta = list(history, modified, website),
                    namespaces = c(skos = &quot;http://www.w3.org/2004/02/skos/core#&quot;,
                                   foaf = &quot;http://xmlns.com/foaf/0.1/&quot;),
                    nexml=birds)
  nexml_write(birds, 
              file = &quot;example.xml&quot;)
</code></pre>

<pre><code>[1] &quot;example.xml&quot;
</code></pre>

<h3>Taxonomic identifiers</h3>

<p>Add taxonomic identifier metadata to the OTU elements:</p>

<!-- This block relies on a robust internet connection that can occassionally fail.  Also it's a bit slow, so don't run it. After all, this command is tested in the unit tests.-->

<pre><code class="r">nex &lt;- add_trees(bird.orders)
nex &lt;- taxize_nexml(nex)
</code></pre>

<h2>Working with character data</h2>

<p>NeXML also provides a standard exchange format for handling character data.  The R platform is particularly popular in the context of phylogenetic comparative methods, which consider both a given phylogeny and a set of traits.  NeXML provides an ideal tool for handling this metadata.  </p>

<h3>Extracting character data</h3>

<p>We can load the library, parse the NeXML file and extract both the characters and the phylogeny.  </p>

<pre><code class="r">library(RNeXML)
nexml &lt;- read.nexml(system.file(&quot;examples&quot;, &quot;comp_analysis.xml&quot;, package=&quot;RNeXML&quot;))
traits &lt;- get_characters(nexml)
tree &lt;- get_trees(nexml)
</code></pre>

<p>(Note that <code>get_characters</code> would return both discrete and continuous characters together in the same data.frame, but we use <code>get_characters_list</code> to get separate data.frames for the continuous <code>characters</code> block and the discrete <code>characters</code> block).  </p>

<p>We can then fire up <code>geiger</code> and fit, say, a Brownian motion model the continuous data and a Markov transition matrix to the discrete states:  </p>

<pre><code class="r">library(geiger)
fitContinuous(tree, traits[1], ncores=1)
</code></pre>

<pre><code>GEIGER-fitted comparative model of continuous data
 fitted &#39;BM&#39; model parameters:
    sigsq = 1.166011
    z0 = 0.255591

 model summary:
    log-likelihood = -20.501183
    AIC = 45.002367
    AICc = 46.716652
    free parameters = 2

Convergence diagnostics:
    optimization iterations = 100
    failed iterations = 0
    frequency of best fit = 1.00

 object summary:
    &#39;lik&#39; -- likelihood function
    &#39;bnd&#39; -- bounds for likelihood search
    &#39;res&#39; -- optimization iteration summary
    &#39;opt&#39; -- maximum likelihood parameter estimates
</code></pre>

<pre><code class="r">fitDiscrete(tree, traits[2], ncores=1)
</code></pre>

<pre><code>GEIGER-fitted comparative model of discrete data
 fitted Q matrix:
                0           1
    0 -0.07308302  0.07308302
    1  0.07308302 -0.07308302

 model summary:
    log-likelihood = -4.574133
    AIC = 11.148266
    AICc = 11.648266
    free parameters = 1

Convergence diagnostics:
    optimization iterations = 100
    failed iterations = 0
    frequency of best fit = 1.00

 object summary:
    &#39;lik&#39; -- likelihood function
    &#39;bnd&#39; -- bounds for likelihood search
    &#39;res&#39; -- optimization iteration summary
    &#39;opt&#39; -- maximum likelihood parameter estimates
</code></pre>

<hr/>

<p><a href="http://ropensci.org"><img src="http://ropensci.org/public_images/github_footer.png" alt="ropensci footer"/></a></p>

</body>

</html>
